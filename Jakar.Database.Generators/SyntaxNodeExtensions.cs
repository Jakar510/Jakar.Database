/*
// Jakar.Extensions :: Jakar.Database
// 09/07/2023  10:38 PM

using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Npgsql.PostgresTypes;



namespace Jakar.Database.Generators;


// <auto-generated/>
// This file is produced by the TableRecordGenerator – do not edit.



/// <summary> An incremental source generator that implements <see cref="ITableRecord{TSelf}"/> on every partial class/struct that contains a public constant field called <c> TABLE_NAME </c>. </summary>
[Generator]
public sealed class TableRecordGenerator : IIncrementalGenerator
{
    public void Initialize( IncrementalGeneratorInitializationContext context )
    {
        // 1. Find all class/struct declarations that might be a candidate.
        IncrementalValuesProvider<RecordCandidate> typeDeclarations = context.SyntaxProvider.CreateSyntaxProvider(static ( node, _ ) => node is ClassDeclarationSyntax or StructDeclarationSyntax, static ( ctx, _ ) => GetRecordCandidate(ctx))
                                                                             .Where(static candidate => candidate is not null);

        // 2. Combine the compilation with the collected records.
        IncrementalValueProvider<(Compilation Left, ImmutableArray<RecordCandidate> Right)> compilationAndCandidates = context.CompilationProvider.Combine(typeDeclarations.Collect());

        // 3. Emit one source file per record.
        context.RegisterSourceOutput(compilationAndCandidates,
                                     ( spc, data ) =>
                                     {
                                         ( Compilation compilation, ImmutableArray<RecordCandidate> records ) = data;

                                         foreach ( var rec in records )
                                         {
                                             if ( rec is null ) { continue; }

                                             string source = EmitRecordSource(rec, compilation);
                                             spc.AddSource($"{rec.TypeName}_TableRecord.g.cs", SourceText.From(source, Encoding.UTF8));
                                         }
                                     });
    }

    /// <summary> Extracts the metadata that is needed to generate the source. </summary>
    private static RecordCandidate? GetRecordCandidate( GeneratorSyntaxContext ctx )
    {
        if ( ctx.Node is not (ClassDeclarationSyntax or StructDeclarationSyntax) syntax ) { return null; }

        INamedTypeSymbol? typeSymbol = ctx.SemanticModel.GetDeclaredSymbol(syntax) as INamedTypeSymbol;
        if ( typeSymbol is null ) { return null; }

        // Must be declared as partial – we can only add an interface implementation in a partial type.
        if ( !syntax.Modifiers.Any(SyntaxKind.PartialKeyword) ) { return null; }

        // Find a public const string called TABLE_NAME
        IFieldSymbol? tableNameField = typeSymbol.GetMembers()
                                                 .OfType<IFieldSymbol>()
                                                 .FirstOrDefault(f => f.IsConst && f.Type.SpecialType == SpecialType.System_String && f.Name == "TABLE_NAME");

        if ( tableNameField is null ) { return null; }

        // Gather all *public instance* properties that have both a getter and a setter
        // and that are not marked with [DbIgnore].
        List<IPropertySymbol> props = typeSymbol.GetMembers()
                                                .OfType<IPropertySymbol>()
                                                .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                                                            !p.IsStatic                                     &&
                                                            p.GetMethod is not null                         &&
                                                            p.SetMethod is not null                         &&
                                                            !p.GetAttributes()
                                                              .Any(a => a.AttributeClass?.Name == "DbIgnoreAttribute"))
                                                .ToList();

        if ( props.Count == 0 ) { return null; }

        // Build property metadata – this is where the mapping to PostgreSQL types is performed.
        List<PropertyMetaData> meta = new();
        foreach ( IPropertySymbol prop in props ) { meta.Add(BuildPropertyMetaData(prop)); }

        // Sort alphabetically by the property name so that PropertyMetaData is deterministic.
        meta.Sort(( x, y ) => string.CompareOrdinal(x.PropertyName, y.PropertyName));

        return new RecordCandidate
               {
                   TypeSymbol = typeSymbol,
                   Namespace = typeSymbol.ContainingNamespace.IsGlobalNamespace
                                   ? null
                                   : typeSymbol.ContainingNamespace.ToDisplayString(),
                   TypeName       = typeSymbol.Name,
                   TableNameField = tableNameField,
                   PropertyMetas  = meta
               };
    }

    /// <summary> Builds the metadata for a single property. </summary>
    private static PropertyMetaData BuildPropertyMetaData( IPropertySymbol prop )
    {
        // Column name = snake_case of the property name
        string columnName = ToSnakeCase(prop.Name);

        // PostgreSQL type – based on the CLR type
        PostgresType postgresType = MapPostgresType(prop);

        // Column options
        ColumnOptions options = ColumnOptions.None;

        if ( prop.GetAttributes()
                 .Any(a => a.AttributeClass?.Name == "KeyAttribute") ) { options |= ColumnOptions.PrimaryKey; }

        // Nullable flag – reference types are nullable, nullable value types too.
        bool isNullable = prop.NullableAnnotation == NullableAnnotation.Annotated || prop.Type.IsReferenceType;
        if ( isNullable ) { options |= ColumnOptions.Nullable; }

        // Length – only used for string types that carry a MaxLength/Length attribute
        SizeInfo length = SizeInfo.Default;

        AttributeData? maxLen = prop.GetAttributes()
                                    .FirstOrDefault(a => a.AttributeClass?.Name == "MaxLengthAttribute");

        if ( maxLen is not null )
        {
            int len = (int)maxLen.ConstructorArguments[0].Value!;
            length = new LengthInfo(len);
        }

        return new PropertyMetaData
               {
                   PropertyName = prop.Name,
                   PropertyType = prop.Type,
                   ColumnName   = columnName,
                   PostgresType = postgresType,
                   Options      = options,
                   Length       = length
               };
    }

    /// <summary> Very small helper – turns CamelCase → snake_case. </summary>
    private static string ToSnakeCase( string text )
    {
        if ( string.IsNullOrEmpty(text) ) { return text; }

        StringBuilder sb = new();

        for ( int i = 0; i < text.Length; i++ )
        {
            char c = text[i];

            if ( char.IsUpper(c) )
            {
                if ( i > 0 ) { sb.Append('_'); }

                sb.Append(char.ToLowerInvariant(c));
            }
            else { sb.Append(c); }
        }

        return sb.ToString();
    }

    /// <summary> Maps the CLR type to the appropriate PostgreSQL type. The mapping is intentionally very small – only the types that appear in the sample code. </summary>
    private static PostgresType MapPostgresType( IPropertySymbol prop )
    {
        ITypeSymbol t = prop.Type;

        return t.SpecialType switch
               {
                   SpecialType.System_String          => PostgresType.Varchar,
                   SpecialType.System_Int32           => PostgresType.Int4,
                   SpecialType.System_Int64           => PostgresType.Int8,
                   SpecialType.System_SByte           => PostgresType.Int2,
                   SpecialType.System_Single          => PostgresType.Float4,
                   SpecialType.System_Double          => PostgresType.Float8,
                   SpecialType.System_Decimal         => PostgresType.Numeric,
                   SpecialType.System_DateTime        => PostgresType.Timestamp,
                   SpecialType.System_DateTimeOffset  => PostgresType.TimestampTz,
                   SpecialType.System_Boolean         => PostgresType.Boolean,
                   SpecialType.System_Guid            => PostgresType.Uuid,
                   _ when t.TypeKind == TypeKind.Enum => PostgresType.Int4, // Enums as integers
                   _                                  => PostgresType.Text  // Fallback
               };
    }

    /// <summary> Emits the final source file for a single record. </summary>
    private static string EmitRecordSource( RecordCandidate rec, Compilation compilation )
    {
        StringBuilder sb = new();



        #region Usings

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using Npgsql;");
        sb.AppendLine("using NpgsqlTypes;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using System.CodeDom.Compiler;");

        #endregion



        #region Namespace

        if ( !string.IsNullOrEmpty(rec.Namespace) )
        {
            sb.AppendLine($"namespace {rec.Namespace}");
            sb.AppendLine("{");
        }

        #endregion



        #region Generated attribute

        sb.AppendLine("[GeneratedCode(\"TableRecordGenerator\", \"1.0\")]");

        #endregion



        #region Type declaration

        string typeKind = rec.TypeSymbol.TypeKind == TypeKind.Struct
                              ? "partial struct"
                              : "partial class";

        sb.AppendLine($"{typeKind} {rec.TypeName} : ITableRecord<{rec.TypeName}>");
        sb.AppendLine("{");

        #endregion



        #region Static fields – ClassProperties, PropertyCount

        sb.AppendLine("    public static ReadOnlyMemory<PropertyInfo> ClassProperties => typeof(" + rec.TypeName + ").GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty | BindingFlags.GetProperty);");
        sb.AppendLine("    public static int PropertyCount => ClassProperties.Length;");

        #endregion



        #region Static field – TableName

        sb.AppendLine($"    public static string TableName => {rec.TypeName}.TABLE_NAME;");

        #endregion



        #region Static readonly PropertyMetaData (alphabetised)

        sb.AppendLine("    public static readonly FrozenDictionary<string, ColumnMetaData> PropertyMetaData = new FrozenDictionary<string, ColumnMetaData>(new SortedDictionary<string, ColumnMetaData>(StringComparer.InvariantCultureIgnoreCase)");
        sb.AppendLine("    {");

        foreach ( PropertyMetaData p in rec.PropertyMetas )
        {
            // Build options string
            string optsStr = p.Options == ColumnOptions.None
                                 ? "ColumnOptions.None"
                                 : $"ColumnOptions.{p.Options.ToString().Replace(",", " | ColumnOptions.")}";

            sb.AppendLine($"        [\"{p.PropertyName}\"] = new ColumnMetaData(\"{p.PropertyName}\", \"{p.ColumnName}\", PostgresType.{p.PostgresType}, {optsStr}),");
        }

        sb.AppendLine("    });");

        #endregion



        #region CreateTable method

        sb.AppendLine("    public static MigrationRecord CreateTable(ulong migrationID)");
        sb.AppendLine("    {");
        sb.AppendLine("        var sb = new StringBuilder();");
        sb.AppendLine("        sb.AppendLine($\"CREATE TABLE {TableName} (\\n      \");");
        sb.AppendLine("        foreach (var kvp in PropertyMetaData)");
        sb.AppendLine("        {");
        sb.AppendLine("            var meta = kvp.Value;");
        sb.AppendLine("            sb.Append(\"    \");");
        sb.AppendLine("            sb.Append(meta.ColumnName);");
        sb.AppendLine("            sb.Append(\" \");");
        sb.AppendLine("            sb.Append(meta.DataType);");
        sb.AppendLine("            if (meta.IsPrimaryKey) sb.Append(\" PRIMARY KEY\");");
        sb.AppendLine("            if (!meta.IsNullable) sb.Append(\" NOT NULL\"); else sb.Append(\" NULL\");");
        sb.AppendLine("            sb.AppendLine(\",\\n      \");");
        sb.AppendLine("        }");
        sb.AppendLine("        if (PropertyMetaData.Count > 0)");
        sb.AppendLine("        {");
        sb.AppendLine("            sb.Length -= 6; // strip the final comma and indentation");
        sb.AppendLine("        }");
        sb.AppendLine("        sb.AppendLine(\")\\n;\");");
        sb.AppendLine("        return new MigrationRecord(migrationID, sb.ToString());");
        sb.AppendLine("    }");

        #endregion



        #region ToPair

        sb.AppendLine("    public RecordPair<" + rec.TypeName + "> ToPair() => new RecordPair<" + rec.TypeName + ">(ID, DateCreated);");

        #endregion



        #region Create (from reader)

        sb.AppendLine("    public static " + rec.TypeName + " Create(NpgsqlDataReader reader)");
        sb.AppendLine("    {");
        sb.AppendLine("        var instance = new " + rec.TypeName + "();");

        foreach ( PropertyMetaData p in rec.PropertyMetas )
        {
            string propTypeStr = p.PropertyType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            sb.AppendLine($"        instance.{p.PropertyName} = reader.GetFieldValue<{propTypeStr}>(reader.GetOrdinal(\"{p.ColumnName}\"));");
        }

        sb.AppendLine("        return instance;");
        sb.AppendLine("    }");

        #endregion



        #region NewID

        sb.AppendLine("    public " + rec.TypeName + " NewID(RecordID<" + rec.TypeName + "> id)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var newInstance = new {rec.TypeName}");
        sb.AppendLine("        {");
        sb.AppendLine("            ID = id,");
        foreach ( PropertyMetaData p in rec.PropertyMetas.Where(p => p.PropertyName != "ID") ) { sb.AppendLine($"            {p.PropertyName} = this.{p.PropertyName},"); }

        sb.AppendLine("        };");
        sb.AppendLine("        return newInstance;");
        sb.AppendLine("    }");

        #endregion



        sb.AppendLine("}"); // end of type



        #region End of namespace

        if ( !string.IsNullOrEmpty(rec.Namespace) ) { sb.AppendLine("}"); }

        #endregion



        return sb.ToString();
    }



    #region Helper types used by the generator

    private sealed class RecordCandidate
    {
        public required string?                Namespace      { get; init; }
        public          List<PropertyMetaData> PropertyMetas  { get; init; } = [];
        public required IFieldSymbol           TableNameField { get; init; }
        public required string                 TypeName       { get; init; }
        public required INamedTypeSymbol       TypeSymbol     { get; init; }
    }



    private sealed class PropertyMetaData
    {
        public required string        ColumnName   { get; init; }
        public required SizeInfo      Length       { get; init; } // currently unused in the generated code but kept for future extension
        public required ColumnOptions Options      { get; init; }
        public required PostgresType  PostgresType { get; init; }
        public required string        PropertyName { get; init; }
        public required ITypeSymbol   PropertyType { get; init; }
    }

    #endregion
}
*/
