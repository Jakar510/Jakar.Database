// Jakar.Extensions :: Jakar.SqlBuilder
// 3/1/2024  23:20

namespace Jakar.Database;


/*
 Numeric Types

       INTEGER: A whole number, varying in column.Size from SMALLINT to BIGINT depending on the storage column.Size and range.
       DECIMAL(Precision, Scale): A fixed-point number with a specified number of digits before and after the decimal point.
       NUMERIC(Precision, Scale): Similar to DECIMAL, often used interchangeably.
       FLOAT(Precision): A floating-point number with machine-dependent precision.
       REAL and DOUBLE PRECISION: Floating-point numbers with more precision than FLOAT.

   String Types

       CHAR(Size): A fixed-length character string, space-padded.
       VARCHAR(Size): A variable-length character string.
       TEXT: A large text data type, with column.Size limits depending on the DBMS.

   Date and Time Types

       DATE: Stores a date (year, month, day).
       TIME: Stores a time of day without a date.
       DATETIME: Stores both date and time.
       TIMESTAMP: Stores a timestamp, often used for recording when a row was last updated.

   Binary Types

       BINARY(Size): Similar to CHAR, but stores binary bytes.
       VARBINARY(Size): Similar to VARCHAR, but for binary bytes.
       BLOB: Binary Large Object, a large piece of binary data, such as images or audio.

   Boolean Type

       BOOLEAN: Stores TRUE or FALSE.

   Specialized Types

       ENUM: A string object that can have only one value chosen from a list of predefined values.
       SET: Similar to ENUM, but can store multiple values from a predefined list.
       UUID/GUID: A special type for storing Universally Unique Identifiers.
       JSON: Stores JSON data, allowing for complex data structures within a single database field.
       ARRAY: Supported by some databases like PostgreSQL, allowing storage of arrays.
       XML: For storing XML data, with some DBMS providing additional functions to manipulate XML data.

   Geography and Geometry Types (Spatial Types)

       POINT, LINESTRING, POLYGON, and more: These types are used for storing and manipulating spatial data, such as coordinates and shapes, especially in databases that support GIS (Geographic Information Systems).
 */



public readonly ref struct SqlTableBuilder<TSelf>( TableMetaData columns )
    where TSelf : class, ITableRecord<TSelf>
{
    public static string Default => new SqlTableBuilder<TSelf>(TSelf.PropertyMetaData).Build();


    public string Build()
    {
        StringBuilder query     = new(10240);
        string        tableName = TSelf.TableName;

        query.Append("CREATE TABLE IF NOT EXISTS ");
        query.Append(tableName);
        query.Append(" (\n");
        int maxColumnNameLength = columns.MaxColumnNameLength;
        int maxDataTypeLength   = columns.MaxDataTypeLength;

        foreach ( ( string columnName, ColumnMetaData column ) in columns )
        {
            ColumnOptions options  = column.Options;
            string        dataType = column.DataType;

            query.Append($"    {columnName.PadRight(maxColumnNameLength)} {dataType.PadRight(maxDataTypeLength)}");

            if ( ( options & ColumnOptions.Unique ) != 0 ) { query.Append(" UNIQUE"); }

            query.Append(column.IsNullable
                             ? " NULL"
                             : " NOT NULL");

            if ( ( options & ColumnOptions.AlwaysIdentity ) != 0 ) { query.Append(" GENERATED ALWAYS AS IDENTITY"); }

            else if ( ( options & ColumnOptions.DefaultIdentity ) != 0 ) { query.Append(" GENERATED BY DEFAULT AS IDENTITY"); }

            if ( ( options & ColumnOptions.PrimaryKey ) != 0 ) { query.Append(" PRIMARY KEY"); }

            if ( column.Checks?.IsValid is true )
            {
                query.Append(" CHECK ( ");

                query.AppendJoin(column.Checks.Value.And
                                     ? AND
                                     : OR,
                                 column.Checks.Value.Checks);

                query.Append(" )");
            }

            query.Append('\n');
        }

        query.Append(')');
        query.Append('\n');
        query.Append('\n');
        int maxIndexColumnNameLength = columns.MaxIndexColumnNameLength;

        foreach ( ( string columnName, ColumnMetaData column ) in columns )
        {
            if ( string.IsNullOrWhiteSpace(column.IndexColumnName) ) { continue; }

            Debug.Assert(column.IndexColumnName.Contains(columnName, StringComparison.InvariantCultureIgnoreCase));

            query.Append($"CREATE INDEX IF NOT EXISTS {column.IndexColumnName.PadRight(maxIndexColumnNameLength)} ON {tableName} ({columnName});\n");
        }

        return query.ToString();
    }
}
