// Jakar.Extensions :: Jakar.Database
// 10/18/2025  23:29

namespace Jakar.Database;


public readonly ref struct SqlTable<TSelf> : IDisposable
    where TSelf : class, ITableRecord<TSelf>
{
    internal readonly Dictionary<string, ColumnMetaData> Columns = new(StringComparer.InvariantCultureIgnoreCase);


    public SqlTable() { }
    public static SqlTable<TSelf> Empty => new();

    public static SqlTable<TSelf> Default => Empty.WithColumn(ColumnMetaData.ID)
                                                  .WithColumn(ColumnMetaData.LastModified)
                                                  .WithColumn(ColumnMetaData.DateCreated);


    public static string CreateTable()
    {
        TableMetaData<TSelf> columns   = TSelf.PropertyMetaData;
        StringBuilder        query     = new(10240);
        string               tableName = TSelf.TableName;

        query.Append("CREATE TABLE IF NOT EXISTS ");
        query.Append(tableName);
        query.Append(" (\n");
        int maxColumnNameLength = columns.MaxColumnNameLength;
        int maxDataTypeLength   = columns.MaxDataTypeLength;
        int index               = 0;

        foreach ( ( string columnName, ColumnMetaData column ) in columns )
        {
            ColumnOptions options  = column.Options;
            string        dataType = column.DataType;

            query.Append($"    {columnName.PadRight(maxColumnNameLength)} {dataType.PadRight(maxDataTypeLength)}");

            if ( ( options & ColumnOptions.PrimaryKey ) != 0 ) { query.Append(" PRIMARY KEY"); }
            else
            {
                query.Append(column.IsNullable
                                 ? " NULL"
                                 : " NOT NULL");

                if ( ( options & ColumnOptions.Unique ) != 0 ) { query.Append(" UNIQUE"); }

                if ( ( options & ColumnOptions.AlwaysIdentity ) != 0 ) { query.Append(" GENERATED ALWAYS AS IDENTITY"); }

                else if ( ( options & ColumnOptions.DefaultIdentity ) != 0 ) { query.Append(" GENERATED BY DEFAULT AS IDENTITY"); }


                if ( column.Checks?.IsValid is true )
                {
                    query.Append(" CHECK ( ");

                    query.AppendJoin(column.Checks.Value.And
                                         ? AND
                                         : OR,
                                     column.Checks.Value.Checks);

                    query.Append(" )");
                }
            }


            if ( ++index < columns.Count ) { query.Append(','); }

            query.Append('\n');
        }

        query.Append(')');
        query.Append('\n');
        query.Append('\n');
        int maxIndexColumnNameLength = columns.MaxIndexColumnNameLength;

        foreach ( ( string columnName, ColumnMetaData column ) in columns )
        {
            if ( string.IsNullOrWhiteSpace(column.IndexColumnName) ) { continue; }

            Debug.Assert(column.IndexColumnName.Contains(columnName, StringComparison.InvariantCultureIgnoreCase));

            query.Append($"CREATE INDEX IF NOT EXISTS {column.IndexColumnName.PadRight(maxIndexColumnNameLength)} ON {tableName} ({columnName});\n");
        }

        query.Append($"""

                      CREATE TRIGGER {nameof(MigrationRecord.SetLastModified).SqlColumnName()}
                      BEFORE INSERT OR UPDATE ON {tableName}
                      FOR EACH ROW
                      EXECUTE FUNCTION {nameof(MigrationRecord.SetLastModified).SqlColumnName()}();
                      """);

        return query.ToString();
    }


    public void Dispose() => Columns?.Clear();


    // public SqlTableBuilder<TSelf> WithIndexColumn( string indexColumnName, string columnName ) => WithColumn(ColumnMetaData.Indexed(columnName, indexColumnName));


    public SqlTable<TSelf> With_DateCreated()    => WithColumn(ColumnMetaData.DateCreated);
    public SqlTable<TSelf> With_CreatedBy()      => WithColumn(ColumnMetaData.CreatedBy);
    public SqlTable<TSelf> With_AdditionalData() => WithColumn(ColumnMetaData.AdditionalData);


    public SqlTable<TSelf> WithColumn_Json( string propertyName, ColumnOptions options = ColumnOptions.Nullable, ColumnCheckMetaData? checks = null )
    {
        ColumnMetaData column = new(propertyName, PostgresType.Json, options, null, SizeInfo.Default, checks);
        return WithColumn(column);
    }
    public SqlTable<TSelf> WithColumn<TValue>( string propertyName, ColumnOptions options, SizeInfo length = default, ColumnCheckMetaData? checks = null )
    {
        if ( typeof(TValue) == typeof(RecordID<TSelf>) || typeof(TValue) == typeof(RecordID<TSelf>?) ) { throw new InvalidOperationException($"Use the other overload of {nameof(WithColumn)} instead for primary key columns {RecordID<TSelf>.Description()}."); }

        if ( typeof(TValue).Name.StartsWith("RecordID", StringComparison.InvariantCultureIgnoreCase) ) { throw new InvalidOperationException($"Use the other overload of {nameof(WithColumn)} instead for primary key columns ({nameof(RecordID<>)})."); }

        if ( typeof(TValue).IsEnum ) { throw new InvalidOperationException($"Use the other overload of {nameof(WithColumn)} instead for Enum columns ({typeof(TValue).Name})."); }

        PostgresType   dbType = typeof(TValue).GetPostgresType(ref options, ref length);
        ColumnMetaData column = new(propertyName, dbType, options, null, length, checks);
        return WithColumn(column);
    }
    public SqlTable<TSelf> WithColumn<TValue>( string propertyName, bool isNullable, ColumnCheckMetaData? checks = null )
        where TValue : struct, Enum
    {
        ColumnOptions options = ColumnOptions.ForeignKey;
        if ( isNullable ) { options |= ColumnOptions.Nullable; }

        SizeInfo length = Enum.GetValues<TValue>()
                              .AsValueEnumerable()
                              .Max(x => x.ToString()
                                         .Length);

        ColumnMetaData column = new(propertyName, PostgresType.String, options, typeof(TValue).Name, length, checks);
        return WithColumn(column);
    }
    public SqlTable<TSelf> WithColumn<TRecord>( string propertyName, ColumnCheckMetaData? checks = null )
        where TRecord : class, ITableRecord<TRecord>
    {
        ColumnMetaData column = new(propertyName, PostgresType.Guid, ColumnOptions.ForeignKey, TRecord.TableName, checks: checks);
        return WithColumn(column);
    }
    public SqlTable<TSelf> WithColumn( ColumnMetaData column )
    {
        try
        {
        #if DEBUG
            int check = Columns.Values.Count(static x => x.IsPrimaryKey);
            if ( column.IsPrimaryKey && check > 0 ) { throw new InvalidOperationException($"Must be exactly one primary key defined for {typeof(TSelf).Name}. Instead there are {check} primary keys."); }
        #endif

            Columns.Add(column.ColumnName, column);
            return this;
        }
        catch ( Exception e ) { throw new InvalidOperationException(column.ColumnName, e); }
    }


    public TableMetaData<TSelf> Build()
    {
        int check = Columns.Values.Count(static x => x.IsPrimaryKey);
        if ( check != 1 ) { throw new InvalidOperationException($"Must be exactly one primary key defined for {typeof(TSelf).Name}. Instead there are {check} primary keys."); }

        return Columns.ToFrozenDictionary();
    }
}
